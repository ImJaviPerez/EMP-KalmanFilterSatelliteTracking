---
# Este documento tiene encoding: UTF-8
title: "TFM. Máster de Modelización Matemática Estadística y Computación"
subtitle: "Localización de satélites"
author: "F. Javier Pérez Ramírez. UPV-EHU"
date: "27 de enero de 2020"
output:
  pdf_document:
    keep_tex: yes
    number_sections: yes
    toc: yes
    toc_depth: 3
    fig_caption: yes
    fig_height: 4
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
    number_sections: yes
header-includes:
- \usepackage{float}          # To insert figures caption
- \floatplacement{figure}{H}  # To insert figures caption
- \usepackage{xcolor}
- \usepackage{framed}
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhead[LE,RO]{TFM}
- \fancyfoot{}
- \fancyfoot[LO,RE]{FJP. 2020}
- \fancyfoot[LE,RO]{\thepage}
bibliography: ../biblioTFM.bib
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message = FALSE, cache=TRUE)
#    include = FALSE prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.
#    echo = FALSE prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.
#    message = FALSE prevents messages that are generated by code from appearing in the finished file.
#    warning = FALSE prevents warnings that are generated by code from appearing in the finished.
#    fig.cap = "..." adds a caption to graphical results.
#    results='asis' = output as-is, i.e., write raw results from R into the output document
#    eval = If FALSE, knitr will not run the code in the code chunk.
```

```{r echo=FALSE}
#
# Error in tools::file_path_as_absolute(output_file)
#
# It seems the bug is related with 1.9 version of rmarkdown, so the solution is to return to 1.8 version
#
# install.packages("devtools")
# library(devtools)
# install_version("rmarkdown",version=1.8)
#
```

```{r echo=FALSE}
# Remove variables
### rm(list=ls())
```

```{r}
anglesInPI <- function(dataColumn){
  # Change angles between -pi, pi  
  betweenPI_PI <- ifelse(dataColumn > pi, dataColumn - 2*pi,
                         ifelse(dataColumn < -pi, dataColumn + 2*pi, dataColumn))
  return(betweenPI_PI)
}

anglesIn0to2PI <- function(dataColumn){
  # Change angles between -pi, pi  
  betweenPI_PI <- ifelse(dataColumn > 2*pi, dataColumn - 2*pi,
                         ifelse(dataColumn < -0, dataColumn + 2*pi, dataColumn))
  return(betweenPI_PI)
}


RAD_TO_DEG <- 180/pi
```

# Tratamiento de datos{#sec:ttoDatos}

```{r}
# Load libraries
# zoo object creation
library(zoo)
library(dlm)
library(data.table)
```


```{r}
# Data frame with movement data
### angXY.df <- read.delim(file="resultadosKalman_X_out.txt", row.names=NULL)
angXY.df <- read.delim(file="resultadosKalman_out.txt", row.names=NULL)
```

```{r eval=FALSE}
# Duplicated rows
# Select index
id <- angXY.df$micros
angXY.df[!duplicated(angXY.df$micros),]
# # Select all but duplicates = Delete duplicated rows
angXY.df <- angXY.df[!duplicated(id),]
```

```{r}
# Calculate delta t in milliseconds
require(data.table)
angXY.df$dt <- (angXY.df$micros - shift(angXY.df$micros))/1000
# angXY.df$dt[1] = NA, so Fisrt dt = second dt
angXY.df$dt[1] <- angXY.df$dt[2]

#### (angXY.df$micros[2] - angXY.df$micros[1])/1000
#### range(angXY.df$dt)
```

Para el problema que estamos tratando bastaría con la aproximación por rectángulos dado que la diferencia entre ambas es "pequeña": en ningún caso se superan los 6 º de diferencia (ver figura (\ref{fig:diffTrapezRect})).
```{r}
6 / RAD_TO_DEG
```


```{r eval=FALSE}
# Inclinacion
IL = 77.70894 * pi / 180
IL = 58.4764 * pi / 180

# Declinacion
dL = -0.16217 * pi / 180
# offset inicial
( roll0 = atan2(sin(IL), (cos(IL)*cos(dL))) )
( pitch0 = atan2( (cos(IL)*sin(dL)), sin(IL)) )
(yaw0 = (pi/2) - dL)

# Restar offset en la brujula
angXY.df$rollXcompass <- angXY.df$rollXcompass - roll0
angXY.df$pitchYcompass <- angXY.df$pitchYcompass - pitch0
angXY.df$yawZcompass <- angXY.df$yawZcompass - yaw0
```





```{r  fig.pos="H", fig.cap="\\label{fig:diffTrapezRect}Diferencias entre el ajuste trapezoidal y el ajuste con rectángulos."}
# We will need some more variables
# Gyroscope angles
# Rectangle "integration"
# Inicial angle + cumsum(...)
rectangle.X <- angXY.df$rollAccX[1] + cumsum(angXY.df$dt * angXY.df$gyroXrate)/1000
rectangle.Y <- angXY.df$pitchAccY[1] + cumsum(angXY.df$dt * angXY.df$gyroYrate)/1000
rectangle.Z <- angXY.df$yawAccZ[1] + cumsum(angXY.df$dt * angXY.df$gyroZrate)/1000

# Trapezoidal integration
# Let's  imagine two rectangles with height omega_k and omega_(k-1)
# and width angXY.df$dt/2
require(data.table)
# omega_k + omega_(k-1)
sum.shift.rect <- angXY.df$gyroXrate + shift(angXY.df$gyroXrate)
# sum.shift.rect[1] = NA, so Fisrt angle = second angle
sum.shift.rect[1] <- sum.shift.rect[2]
# Inicial angle + cumsum(...)
trapezium.X <-angXY.df$rollAccX[1] + cumsum(sum.shift.rect * angXY.df$dt / 2)/1000

# omega_k + omega_(k-1)
sum.shift.rect <- angXY.df$gyroYrate + shift(angXY.df$gyroYrate)
# sum.shift.rect[1] = NA, so Fisrt angle = second angle
sum.shift.rect[1] <- sum.shift.rect[2]
# Inicial angle + cumsum(...)
trapezium.Y <- angXY.df$pitchAccY[1] + cumsum(sum.shift.rect * angXY.df$dt / 2)/1000

# omega_k + omega_(k-1)
sum.shift.rect <- angXY.df$gyroZrate + shift(angXY.df$gyroZrate)
# sum.shift.rect[1] = NA, so Fisrt angle = second angle
sum.shift.rect[1] <- sum.shift.rect[2]
# Inicial angle + cumsum(...)
trapezium.Z <- angXY.df$yawAccZ[1] + cumsum(sum.shift.rect * angXY.df$dt / 2)/1000

par(mfrow=c(3,1))


boxplot((rectangle.X - trapezium.X)*RAD_TO_DEG, horizontal=TRUE, 
        main="Diferencias ajuste (rectagular-trapezoidal). Eje X",  
        cex.main=0.8, xlab="grados")
boxplot((rectangle.Y - trapezium.Y)*RAD_TO_DEG, horizontal=TRUE, 
        main="Diferencias ajuste (rectagular-trapezoidal). Eje Y",  
        cex.main=0.8, xlab="grados")
boxplot((rectangle.Z - trapezium.Z)*RAD_TO_DEG, horizontal=TRUE, 
        main="Diferencias ajuste (rectagular-trapezoidal). Eje Z",  
        cex.main=0.8, xlab="grados")
# Maximum difference between rectangle and trapezium adjustment
max(abs(rectangle.X - trapezium.X))*RAD_TO_DEG
max(abs(rectangle.Y - trapezium.Y))*RAD_TO_DEG
max(abs(rectangle.Z - trapezium.Z))*RAD_TO_DEG
```


```{r}
require(ggplot2)

plotAnglesRectTrapez <- function(theTitle="", dfRectTrapez=dfAux){
  ggplot(data=dfRectTrapez, 
         aes(x=t, y=rectangle*RAD_TO_DEG, colour = "Rectangular")) +
    geom_line() + 
    geom_line(data = dfRectTrapez, aes(x=t, y=trapezium*RAD_TO_DEG, colour = "Trapecios")) +
    scale_colour_manual("", 
                        breaks = c("Rectangular", "Trapecios"),
                        values = c("Rectangular"="blue", "Trapecios"="darkorange")) +
    #ggtitle(theTitle) +
    ylab("Ángulo (º)") + xlab("t (ms)") +
    theme_bw()
}

dfAux <- data.frame(rectangle = rectangle.X, trapezium = trapezium.X, t =  angXY.df$micros/1000)
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje X", dfRectTrapez=dfAux)
dfAux2 <- subset(dfAux,(t>12000 & t<16000))
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje X. Detalle",dfRectTrapez=dfAux2)

dfAux <- data.frame(rectangle = rectangle.Y, trapezium = trapezium.Y, t =  angXY.df$micros/1000)
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje Y", dfRectTrapez=dfAux)
dfAux2 <- subset(dfAux,(t>12000 & t<16000))
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje Y. Detalle",dfRectTrapez=dfAux2)

dfAux <- data.frame(rectangle = rectangle.Z, trapezium = trapezium.Z, t =  angXY.df$micros/1000)
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje Z", dfRectTrapez=dfAux)
dfAux2 <- subset(dfAux,(t>12000 & t<16000))
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje Z. Detalle",dfRectTrapez=dfAux2)
```



```{r}
require(ggplot2)
aux.df <- data.frame(X = (rectangle.X - trapezium.X)*RAD_TO_DEG, Y = (rectangle.Y - trapezium.Y)*RAD_TO_DEG, Z = (rectangle.Z - trapezium.Z)*RAD_TO_DEG)

aux.df <- melt(data=aux.df, measure.vars = c("X", "Y", "Z"))

myBoxplot <- ggplot(data=aux.df ,aes(x=variable,y=value)) +
  geom_boxplot() +
  ##scale_fill_manual(breaks = c("Azimut","Elevación"), values=c("white", "grey")) +
  xlab("Eje") +
  ylab("Diferencias ajuste (rectagular-trapezoidal) (º)")  +
  theme_bw()
  #coord_flip()

dfAux <- data.frame(rectangle = rectangle.X, trapezium = trapezium.X, t =  angXY.df$micros/1000)
dfAux2 <- subset(dfAux,(t>15000 & t<max(dfAux$t)))
myGraphic <- plotAnglesRectTrapez(dfRectTrapez=dfAux2)

library(gridExtra)
grid.arrange(myGraphic, myBoxplot, nrow = 1)
```




Una vez leídos los datos del problema se crean dos nuevas columnas con la suma acumulada de los ángulos proporcionados por los giróscopos tal y como se ha descrito anteriormente (suma acumulada de rectángulos).

```{r}
## # Trapezoidal integration
## angXY.df$csGyroX <- trapezium.X
## angXY.df$csGyroY <- trapezium.Y

# Rectangles integration
angXY.df$csGyroX <- rectangle.X
angXY.df$csGyroY <- rectangle.Y
angXY.df$csGyroZ <- rectangle.Z

# csGyroX must be between [0,2*pi]
indices <- which(angXY.df$csGyroX > 2*pi)
angXY.df$csGyroX[indices] <- angXY.df$csGyroX[indices] - 2*pi
indices <- which(angXY.df$csGyroX < 0)
angXY.df$csGyroX[indices] <- angXY.df$csGyroX[indices] + 2*pi
# csGyroY must be between [0,2*pi]
indices <- which(angXY.df$csGyroY > 2*pi)
angXY.df$csGyroY[indices] <- angXY.df$csGyroY[indices] - 2*pi
indices <- which(angXY.df$csGyroY < 0)
angXY.df$csGyroY[indices] <- angXY.df$csGyroY[indices] + 2*pi
# csGyroZ must be between [0,2*pi]
indices <- which(angXY.df$csGyroZ > 2*pi)
angXY.df$csGyroZ[indices] <- angXY.df$csGyroZ[indices] - 2*pi
indices <- which(angXY.df$csGyroZ < 0)
angXY.df$csGyroZ[indices] <- angXY.df$csGyroZ[indices] + 2*pi

angXY <- zoo(angXY.df[c("rollAccX","pitchAccY","yawAccZ","gyroXrate","gyroYrate","gyroZrate","rollXcompass","pitchYcompass","yawZcompass")], order.by=angXY.df$micros)
```

Una vez cargados los datos, se comprueban su estructura, sus dimensiones y que no contiene valores perdidos.

```{r}
# Return the First part of the Object
head(angXY)
# Object dimensions
cat("\nDimensiones del objeto:", dim(angXY), "\n")
# Number of NAs
cat("\nNúmero de valores perdidos =", length(which(is.na(angXY))))
```

La figura (\ref{fig:initialData}) muestra los datos de movimiento del artilugio: velocidades angulares (`gyroXangle`, `gyroYangle`) en (rad $s^{-1}$),  ángulos del acelerómetro (`acelX`, `acelY`, `acelZ`) en radianes (rad) y ángulos del giróscopo (`csGyroX`, `csGyroY`, `csGyroZ`) en radianes (rad).

```{r fig.pos="H", fig.cap="\\label{fig:initialData}Datos de movimiento del artilugio. Angulos (`acelX`, `acelY``, `acelZ`), velocidades angulares (`gyroXrate`, `gyroYrate`, `gyroZrate`) y ángulos de los giróscopos (`csGyroX`, `csGyroY`, `csGyroZ`)."}
plot.zoo(angXY, 
         xlab = "Tiempo (ms)", main = "Ángulo X. Ángulo Y. Ángulo Z")
```

# Horizontal heading

```{r}
library(ggplot2)
dfData <- data.frame(yawZcompass = angXY.df$heading*RAD_TO_DEG, 
                    horizontalHeadingAngle=angXY.df$horizontalHeadingAngle*RAD_TO_DEG, 
                    kalAngleX=anglesInPI(angXY.df$kalAngleX)*RAD_TO_DEG, 
                    kalAngleY=(angXY.df$kalAngleY)*RAD_TO_DEG, 
                    kalAngleZ=angXY.df$kalAngleZ*RAD_TO_DEG, 
                    accAngleX=anglesInPI(angXY.df$rollAccX)*RAD_TO_DEG, 
                    t=seq(1:nrow(angXY.df)))
headingAnglesGG <- ggplot(data=dfData, 
       aes(x=t, y=yawZcompass, colour="Brújula")) +
  geom_line() +
  scale_colour_manual("", 
                    breaks = c("Brújula", "Brújula proyecc. horizontal",
                               "Giro en torno eje X", "Giro en torno eje Y", "Giro en torno eje Z", "Giro eje X"),
                    values = c("Brújula"="red", 
                               "Brújula proyecc. horizontal"="blue", 
                               "Giro en torno eje X"="darkturquoise",
                               "Giro en torno eje Y"="darkorange4",
                               "Giro en torno eje Z"="darkviolet",
                               "Giro eje X"="black"))
  ## ggtitle("Angulo eje X")
  
headingAnglesGG +
  geom_line(data = dfData, aes(x=t, y=horizontalHeadingAngle, colour = "Brújula proyecc. horizontal")) +
  #geom_line(data = dfData, aes(x=t, y=kalAngleX, colour = "Giro en torno eje X")) +
  #geom_line(data = dfData, aes(x=t, y=kalAngleY, colour = "Giro en torno eje Y")) +
  #geom_line(data = dfData, aes(x=t, y=kalAngleZ, colour = "Giro en torno eje Z")) +
  geom_line(data = dfData, aes(x=t, y=accAngleX, colour = "Giro eje X")) +
  ylab("Ángulo (º)") + xlab("t (ms)") +
  theme_bw()
```
```{r}
mean(angXY.df$yawAccZ - angXY.df$horizontalHeadingAngle)*RAD_TO_DEG
sd(angXY.df$yawAccZ - angXY.df$horizontalHeadingAngle)*RAD_TO_DEG

# Calculate compass yawZ
angXY.df$atan2YawCompas <- atan2(angXY.df$compassRawY, angXY.df$compassRawX)
# calculate horizontal heading
xh <- angXY.df$compassRawX * cos(angXY.df$pitchAccY) - angXY.df$compassRawZ * sin(angXY.df$pitchAccY);
yh <- angXY.df$compassRawX * sin(angXY.df$pitchAccY)*sin(angXY.df$rollAccX) + angXY.df$compassRawY * cos(angXY.df$rollAccX) + angXY.df$compassRawZ * sin(angXY.df$rollAccX)*cos(angXY.df$pitchAccY)
angXY.df$atan2horizHead <- atan2(yh, xh)

par(mfrow=c(2,1))
boxplot((anglesIn0to2PI(angXY.df$atan2horizHead) - angXY.df$horizontalHeadingAngle)*RAD_TO_DEG, horizontal=TRUE)
boxplot((anglesIn0to2PI(angXY.df$atan2YawCompas) - angXY.df$yawZcompass)*RAD_TO_DEG, horizontal=TRUE)
```




# Ángulos
Se muestra el ángulo **roll**, **pitch** y **yaw** de los tres disposivos + kalman

Se plotea el resultado
```{r}
# Plot values
plotAnglesAGC_KmpuKcalc <- function(theAxix="X"){
  if (theAxix == "X")
  {
    dfData <- data.frame(accAngle =anglesInPI(angXY.df$rollAccX)*RAD_TO_DEG, 
                        csGyro=anglesInPI(angXY.df$csGyroX)*RAD_TO_DEG,
                        rotationCompass=anglesInPI(angXY.df$rollXcompass)*RAD_TO_DEG, 
                        kalmanAngleMPU6050=anglesInPI(angXY.df$kalAngleX)*RAD_TO_DEG,
                        t=angXY.df$micros/1000)
  }else if (theAxix == "Y")
  {
    dfData <- data.frame(accAngle = anglesInPI(angXY.df$pitchAccY)*RAD_TO_DEG, 
                        csGyro=anglesInPI(angXY.df$csGyroY)*RAD_TO_DEG,
                        rotationCompass=anglesInPI(angXY.df$pitchYcompass)*RAD_TO_DEG, 
                        kalmanAngleMPU6050=(angXY.df$kalAngleY)*RAD_TO_DEG,
                        t=angXY.df$micros/1000)
  }else if (theAxix == "Z")
  {
    dfData <- data.frame(accAngle = (angXY.df$yawAccZ)*RAD_TO_DEG, 
                        csGyro=angXY.df$csGyroZ*RAD_TO_DEG,
                        rotationCompass=angXY.df$yawZcompass*RAD_TO_DEG, 
                        kalmanAngleMPU6050=(angXY.df$kalAngleZ)*RAD_TO_DEG,
                        t=angXY.df$micros/1000)
  }
  
  mainAnglesGG <- ggplot(data=dfData, 
         aes(x=t, y=accAngle, colour="Acelerómetro")) +
    geom_line() +
    scale_colour_manual("", 
                      breaks = c("Acelerómetro", "Giróscopo", "Brújula", "Kalman MPU"),
                      values = c("Acelerómetro"="blue", 
                                 "Giróscopo"="darkorange", 
                                 "Brújula"="red",
                                 "Kalman MPU" = "black"))
    
    
  mainAnglesGG +
    geom_line(data = dfData, aes(x=t, y=csGyro, colour = "Giróscopo")) +
    geom_line(data = dfData, aes(x=t, y=rotationCompass, colour = "Brújula")) +
    geom_line(data = dfData, aes(x=t, y=kalmanAngleMPU6050, colour = "Kalman MPU")) +
    ylab("Ángulo (rad)") + xlab("t (ms)") +
    theme_bw()
}

plotAnglesAGC_KmpuKcalc(theAxix="X")
plotAnglesAGC_KmpuKcalc(theAxix="Y")
plotAnglesAGC_KmpuKcalc(theAxix="Z")
```


# Kalman{#sec:kalman}

Modelo físico:

$$\theta(t) \approx \theta(t-1) + \Delta t \cdot \omega(t-1)$$

**Elección del modelo**

\begin{equation}\label{eqn:modeloIniPetris}
  \begin{aligned}
    X_t &=& &G_t X_{t-1} + \eta_t,& &\eta_t \stackrel{i.i.d.}{\sim} (0,W_t)& &&\\
    Y_t &=& &F_t X + \epsilon_t,& &\epsilon_t \stackrel{i.i.d.}{\sim} (0,V_t)& &t = 1 \ldots n&
  \end{aligned}
\end{equation}

con $\theta_0 \sim (m_0, C_0)$

La primera de las ecuaciones de (\ref{eqn:modeloIniPetris}) es la ecuación de observación y la segunda es la de estado. En este caso la parte observada corresponderá a los ángulos proporcionados por acelerómetro en torno a los ejes $X$ e $Y$.

Por tanto, podríamos tomar como vector de estado los tres ángulos y las tres velocidades y escribir la ecuación de estado así:

\begin{equation}
\begin{pmatrix}
  \theta_X(t) \\ \theta_Y(t) \\ \theta_Z(t) \\ \omega_X(t) \\ \omega_Y(t) \\ \omega_Z(t)
\end{pmatrix}
=
\begin{pmatrix}
  1 & 0 & 0  & \Delta t & 0 & 0 \\
  0 & 1 & 0  & 0 & \Delta t & 0 \\
  0 & 0 & 1  & 0 & 0 & \Delta t \\
  0 & 0 & 0  & 1 & 0 & 0 \\
  0 & 0 & 0  & 0 & 1 & 0 \\
  0 & 0 & 0  & 0 & 0 & 1 \\
\end{pmatrix}
\begin{pmatrix}
  \theta_X(t-1) \\ \theta_Y(t-1) \\ \theta_Z(t-1) \\ \omega_X(t-1) \\ \omega_Y(t-1) \\ \omega_Z(t-1)
\end{pmatrix} +
\begin{pmatrix}
  \eta_{\theta_X}(t-1) \\ \eta_{\theta_Y}(t-1) \\ \eta_{\theta_Z}(t-1) \\ \eta_{\omega_X}(t-1) \\ \eta_{\omega_Y}(t-1) \\ \eta_{\omega_Z}(t-1)
\end{pmatrix} 
\end{equation}

Esto *se parece* mucho a un modelo con tendencia lineal local, pero la diferencia es que la "pendiente" ya no es un componente inobservable, sino que disponemos de medidas de ella en cada eje.

La ecuación de observación sería:

\begin{equation}
\begin{pmatrix}
  \mathcal{A}_X(t) \\ \mathcal{A}_Y(t) \\ \mathcal{A}_Z(t) \\
  \mathcal{G}_X(t) \\ \mathcal{G}_Y(t) \\ \mathcal{G}_Z(t) \\ 
  \mathcal{C}_X(t) \\ \mathcal{C}_Y(t) \\ \mathcal{C}_Z(t)
\end{pmatrix}
=
\begin{pmatrix}
  1&0&0 & 0&0&0 \\
  0&1&0 & 0&0&0 \\
  0&0&1 & 0&0&0 \\
  0&0&0 & 1&0&0 \\
  0&0&0 & 0&1&0 \\
  0&0&0 & 0&0&1 \\
  1&0&0 & 0&0&0 \\
  0&1&0 & 0&0&0 \\
  0&0&1 & 0&0&0
\end{pmatrix}
\begin{pmatrix}
  \theta_X(t) \\ \theta_Y(t) \\ \theta_Z(t) \\ \omega_X(t) \\ \omega_Y(t) \\ \omega_Z(t)
\end{pmatrix} +
\begin{pmatrix}
  \epsilon_{\mathcal{A}_X}(t) \\ \epsilon_{\mathcal{A}_Y}(t) \\ \epsilon_{\mathcal{A}_Z}(t) \\ 
  \epsilon_{\mathcal{G}_X}(t) \\ \epsilon_{\mathcal{G}_Y}(t) \\ \epsilon_{\mathcal{G}_Z}(t) \\ 
  \epsilon_{\mathcal{C}_X}(t) \\ \epsilon_{\mathcal{C}_Y}(t) \\ \epsilon_{\mathcal{C}_Z}(t) \\ 
\end{pmatrix} 
\end{equation}


Podemos especificar las matrices de sistema del modelo así.
Hay que cambiar la matriz `GG`, para ello se crea la matriz `JGG` [@petris2009dynamic][pág. 45] :
El convenio es el siguiente: si un elemento de `JGG[i,j] = 0` es cero, el correspondiente término de `GG` es invariante. Si por el contrario un elemento de `JGG[i,j] = k` (es un entero `k` entero positivo), el elemento correspondiente de `GG` en el momento `s` se toma de la fila `s` y columna `k` de `X` = `X[s,k]`. Así mismo la matriz `QQ` también variará en el tiempo. O sea si el elemento de `JQQ[i,j] = l` entonces el elemento correspondiente de `QQ` en el momento `s` se toma de la fila `s` y columna `l` de `X` = `X[s,l]`.

```{r}
# Se transforma Delta_t de millisegundos a segundos
Delta_t <- angXY.df$dt/1000

# Notacion Durbin
pDim <- 9
mDim <- 6

# m0 # dimension [m, 1]
a1 <- rep(0,mDim)
# Initial angles
a1[1] <- angXY.df$rollAccX[1]
a1[2] <- angXY.df$pitchAccY[1]
a1[3] <- angXY.df$yawZcompass[1]
# Initial angle rates
a1[4] <- a1[5] <- a1[6] <- 0

# C0 # dimension [m,m]
P1 <-  diag(pi^2, mDim)
P1[4,4] <- P1[5,5] <- P1[6,6] <- (2*pi)^2

# FF # dimension [p,m]
# Matrix by rows
ZZ <- matrix(c(1,0,0, 0,0,0,
               0,1,0, 0,0,0,
               0,0,1, 0,0,0,
               0,0,0, 1,0,0,
               0,0,0, 0,1,0,
               0,0,0, 0,0,1,
               1,0,0, 0,0,0,
               0,1,0, 0,0,0,
               0,0,1, 0,0,0)
             ,nr=pDim, byrow = TRUE)
# Create X matrix
XX <- matrix(0, nrow = length(Delta_t), ncol = 7)

# VV # dimension [p,p]. Observations covariance matrix
HH <- diag(0, pDim)
# JHH time-varying matrix  # dimension [p,p]
JHH <- diag(0, pDim)
# HH matrix accelerometer time-varying elements
# HH accelerometer X axis
JHH[1,1] <- 1
# JHH time-varying values
XX[,JHH[1,1]] <- angXY.df$sd2AccX
# HH accelerometer Y axis
JHH[2,2] <- 2
XX[,JHH[2,2]] <- angXY.df$sd2AccY
# HH accelerometer Z axis
JHH[3,3] <- 3
XX[,JHH[3,3]] <- angXY.df$sd2AccZ
# HH matrix gyroscope time invarying elements
HH[4,4] <- angXY.df[1,"sd2GyroX"] # 0.02691271*0.02691271 # X axis
HH[5,5] <- angXY.df[1,"sd2GyroY"] # 0.01265696*0.01265696 # Y axis
HH[6,6] <- angXY.df[1,"sd2GyroZ"] # 0.01905207*0.01905207 # Z axis
# HH matrix compass time-varying elements
JHH[7,7] <- 4
XX[,JHH[7,7]] <- angXY.df$sd2CompassX
JHH[8,8] <- 5
XX[,JHH[8,8]] <- angXY.df$sd2CompassY
JHH[9,9] <- 6
XX[,JHH[9,9]] <- angXY.df$sd2CompassZ

# GG # dimension [m,m]
TT <- diag(mDim)
# JGG # dimension [m,m]
JTT <- diag(0,mDim)
# TT matrix time-varying elements
JTT[1,4] <- JTT[2,5] <- JTT[3,6] <- 7
# Value of time-varying elements
XX[,7] <- Delta_t

# W # dimension [m,m]
QQ <-  diag(0, mDim)
# QQ matrix angle time invarying elements
QQ[1,1] <- (0.01*pi/180)^2
QQ[2,2] <- (0.01*pi/180)^2
QQ[3,3] <- (0.01*pi/180)^2
# QQ matrix angle-rate time invarying elements
QQ[4,4] <- (1.1E-5*pi/180)^2
QQ[5,5] <- (1.1E-5*pi/180)^2
QQ[6,6] <- (1.1E-5*pi/180)^2

# Create dlm model
modAGC <- dlm(m0 = a1, 
           C0 = P1, 
           FF = ZZ, 
           V = HH, 
           JV = JHH,
           GG = TT, 
           JGG = JTT, 
           W = QQ, 
           X = XX
           ) # matrix(Delta_t, nrow = length(Delta_t), ncol = 1)

modAGC
```

---
# Parece que tiene sentido imaginar que las varianzas correspondientes a diferentes ejes de un mismo sensor (acelerómetro o giróscopo) sean iguales (y en todo caso podríamos probar y contrastar). Lo mismo para las varianzas de observación. Por tanto, podemos especficar una matriz que reemplace parametros estimados en las matrices de covarianzas de nuestro modelo así:
---
```{r eval=FALSE, include=FALSE}
crearModAGC <- function(par) {
  # QQ matrix parameters:
  # Angle
  modAGC$W[1,1] <- modAGC$W[2,2] <- modAGC$W[3,3] <- exp(par[1])
  # Angle rate
  modAGC$W[4,4] <- modAGC$W[5,5] <- modAGC$W[6,6] <- exp(par[2])
  # HH matrix parameters:
  # Accelerometer
  modAGC$V[1,1] <- modAGC$V[2,2] <- modAGC$V[3,3] <- exp(par[3])
  # Gyroscope
  modAGC$V[4,4] <- modAGC$V[5,5] <- modAGC$V[6,6] <- exp(par[4])
  # Compass
  modAGC$V[7,7] <- modAGC$V[8,8] <- modAGC$V[9,9] <- exp(par[5])
  return(modAGC)
}
```
---
# Podemos ahora hacer la estimación:
--- 
```{r calculate_dlmMLE, eval=FALSE, include=FALSE}
resultACG <- dlmMLE(angXY, parm=rep(1,5), build=crearModAGC)
resultACG
```
---
# Reemplazamos los valores de los parámetros en nuestro modelo,
--- 
```{r eval=FALSE, include=FALSE}
modAGC <- crearModAGC(resultACG$par)
modAGC
```

Tomamos las varianzas en cada eje distintas de un mismo sensor (acelerómetro, gisróscopo y brújula). Lo mismo para las varianzas de observación. Por tanto, podemos especficar una matriz que reemplace parametros estimados en las matrices de covarianzas de nuestro modelo así:
```{r eval=TRUE}
crearModAGCDetail <- function(par) {
  # QQ matrix parameters:
  # Angle
  modAGC$W[1,1] <- exp(par[1]) # X Axis
  modAGC$W[2,2] <- exp(par[2]) # Y Axis
  modAGC$W[3,3] <- exp(par[3]) # Z Axis
  # Angle rate
  modAGC$W[4,4] <- exp(par[4]) # X Axis
  modAGC$W[5,5] <- exp(par[5]) # Y Axis
  modAGC$W[6,6] <- exp(par[6]) # Z Axis
  # HH matrix parameters:
  # Accelerometer
  modAGC$V[1,1] <- exp(par[7]) # X Axis
  modAGC$V[2,2] <- exp(par[8]) # Y Axis
  modAGC$V[3,3] <- exp(par[9]) # Z Axis
  # Gyroscope
  modAGC$V[4,4] <- exp(par[10]) # X Axis
  modAGC$V[5,5] <- exp(par[11]) # Y Axis
  modAGC$V[6,6] <- exp(par[12]) # Z Axis
  # Compass
  modAGC$V[7,7] <- exp(par[13]) # X Axis
  modAGC$V[8,8] <- exp(par[14]) # Y Axis
  modAGC$V[9,9] <- exp(par[15]) # Z Axis
  return(modAGC)
}
```

Podemos ahora hacer la estimación:
```{r calculate_dlmMLE_detail, eval=TRUE}
resultACGdetail <- dlmMLE(angXY, parm=rep(1,mDim+pDim), build=crearModAGCDetail)
resultACGdetail
```
Reemplazamos los valores de los parámetros en nuestro modelo,
```{r eval=TRUE}
modAGC <- crearModAGCDetail(resultACGdetail$par)
modAGC
```
```{r}
sqrt(modAGC$W)
```


Y filtramos:
```{r}
# All but first row and columns 1, 2 and 3
kalmanR <- dlmFilter(angXY, modAGC, simplify=TRUE)$m[-1,1:3]
colnames(kalmanR) <- c("X","Y","Z")
kalmanR <- zoo(kalmanR, order.by=index(angXY))
```

Pruebo a hacer un filtro de Kalman a mano. Se utiliza como base el que nos dio F.Tusell en las clases del máster. Pŕactica N4 del curso 2018-2019:

**innovations** [@durbin2012time](p.86):
$$v_t = y_t - E(y_t|Y_{t-1}) = y_t - Z_t a_t$$
```{r}
# kalman3 <- function(y,x0,P0,Q,H) {
kalman3 <- function(y,x0,P0,Q) {
  # Los argumentos son una serie temporal
  # Q variaza del estado
  # H varianza de la obser
  
  # n Numero de muestras
  n <- nrow(y)
  
  # x es un vector de dimension [mDim,n]
  dims <- c(n,mDim)
  x <- array(rep(0,mDim), dims)
  
  # P Es una matriz de dimension [[mDim, mDim],n]
  dims <- c(mDim,mDim,n)
  P <- array(rep(0,mDim*mDim), dims)
  
  # Valores iniciales
  x[1,] <- x0
  P[,,1] <- P0
  
  # Se inicializa la verosimilitud [pDim, mDim]
  dims <- c(pDim,mDim)
  vero <- array(rep(0,pDim*mDim), dims)

  #### # Initialize new Q matrix dimension [m,m]
  #### Q <-  QQ
  # Initialize new H matrix dimension [p,p]
  H <- HH
  # H matrix gyroscope time invarying elements
  H[4,4] <- angXY.df[1,"sd2GyroX"] # X axis
  H[5,5] <- angXY.df[1,"sd2GyroY"] # Y axis
  H[6,6] <- angXY.df[1,"sd2GyroZ"] # Z axis
  

  for (i in 1:(n-1)) {
    if (!anyNA(y[i])) {
      # H varia a lo largo del proceso
      # H matrix gyroscope time-varying elements
      # Accelerometer
      H[1,1] <- angXY.df[i,"sd2AccX"] # X axis
      H[2,2] <- angXY.df[i,"sd2AccY"] # Y axis
      H[3,3] <- angXY.df[i,"sd2AccZ"] # Z axis
      # Compass
      H[7,7] <- angXY.df[i,"sd2CompassX"] # X axis
      H[8,8] <- angXY.df[i,"sd2CompassY"] # Y axis
      H[9,9] <- angXY.df[i,"sd2CompassZ"] # Z axis

            
      # Se calcula la innovacion. Ver Durbin p.86:
      # inno = y_t - E(y_t|Y_{t-1}) = y_t - Z_t a_t
      tmp <- fortify.zoo(y[i], name = "Date")
      inno <- array(tmp[2:(pDim+1)] - ZZ %*% x[i,])
  
      # Aqui Z_t tiene dimension [pDim,mDim]
      F <- ZZ %*% P[,,i] %*% t(ZZ) + H
      
      # La matriz de ganancia K_t = P_t/(P_t + H_t)
      # Durbin, p. 84: K_t = T_t P_t Z'_t / F_t
      K <- TT %*% P[,,i] %*% t(ZZ) %*% solve(F)
  
      vect_inno <- unlist(inno)
      x[i+1,] <- TT %*% x[i,] + K %*% vect_inno
  
      P[,,i+1] <- TT %*% P[,,i] %*% t(TT - K %*% ZZ) +  Q

      vero <- -0.5 * n * log(2*pi) - 0.5 * sum(det(F) + t(vect_inno) %*% solve(F) %*% vect_inno)
    } else {
      x[i+1,] <- x[i,]
      P[,,i+1] <- P[,,i] + Q
    }
  }
  
  vero <- -0.5*vero
  # Se retorna el estado y el valor de la verosimilitud

  return(list(x=x,P=P,vero=vero))
}
```

```{r}
# Initial Values
#### x0 <- rep(0,mDim)
#### x0 <- modAGC$m0
#### P0 <- P1
#### kalmanCalculated   <- kalman3(y=angXY, x0=x0, P0=P1, Q=modAGC$W, H=modAGC$V)

# We put same initial values used with Kalman Filter before to test that we obtain same results
kalmanCalculated   <- kalman3(y=angXY, x0=modAGC$m0, P0=P1, Q=QQ)
# kalmanCalculated$x
# kalmanCalculated$vero
# kalmanCalculated$P
```

Comparemos, por ejemplo, para el ángulo $X$ (`rollAccX`):

Se muestra el ángulo **roll** y **pitch** de los tres disposivos + kalman

Se plotea el resultado
```{r}
# Save values in data frame
angXY.df$calcKalmanX <- kalmanCalculated$x[,1]
angXY.df$calcKalmanY <- kalmanCalculated$x[,2]
angXY.df$calcKalmanZ <- kalmanCalculated$x[,3]

# Plot values
plotAnglesAGC_KmpuKcalc <- function(theAxix="X"){
  if (theAxix == "X")
  {
    dfData <- data.frame(accAngle =anglesInPI(angXY.df$rollAccX), 
                        csGyro=anglesInPI(angXY.df$csGyroX),
                        rotationCompass=anglesInPI(angXY.df$rollXcompass), 
                        kalmanAngleMPU6050=anglesInPI(angXY.df$kalAngleX),
                        kalmanR=anglesInPI(kalmanR$X), 
                        kalmanRCalc=anglesInPI(angXY.df$calcKalmanX),
                        t=angXY.df$micros/1000)
  }else if (theAxix == "Y")
  {
    dfData <- data.frame(accAngle = anglesInPI(angXY.df$pitchAccY), 
                        csGyro=anglesInPI(angXY.df$csGyroY),
                        rotationCompass=(angXY.df$pitchYcompass), 
                        kalmanAngleMPU6050=anglesInPI(angXY.df$kalAngleY),
                        kalmanR=anglesInPI(kalmanR$Y), 
                        kalmanRCalc=anglesInPI(angXY.df$calcKalmanY), 
                        t=angXY.df$micros/1000)
  }else if (theAxix == "Z")
  {
    dfData <- data.frame(accAngle = (angXY.df$yawAccZ), 
                        csGyro=angXY.df$csGyroZ,
                        rotationCompass=angXY.df$yawZcompass, 
                        kalmanAngleMPU6050=angXY.df$kalAngleZ,
                        kalmanR=kalmanR$Z, 
                        kalmanRCalc=angXY.df$calcKalmanZ, 
                        t=angXY.df$micros/1000)
  }
  
  mainAnglesGG <- ggplot(data=dfData, 
         aes(x=t, y=accAngle, colour="Acelerómetro")) +
    geom_line() +
    scale_colour_manual("", 
                      breaks = c("Acelerómetro", "Giróscopo", "Brújula", "Kalman MPU", "kalman R", "Kalman R calc"),
                      values = c("Acelerómetro"="blue", 
                                 "Giróscopo"="darkorange", 
                                 "Brújula"="red",
                                 "Kalman MPU" = "black",
                                 "kalman R"="green",
                                 "Kalman R calc"="darkorchid"))
    
    
  mainAnglesGG +
    geom_line(data = dfData, aes(x=t, y=csGyro, colour = "Giróscopo")) +
    geom_line(data = dfData, aes(x=t, y=rotationCompass, colour = "Brújula")) +
    geom_line(data = dfData, aes(x=t, y=kalmanR, colour = "kalman R")) +
    #geom_line(data = dfData, aes(x=t, y=kalmanRCalc, colour = "Kalman R calc")) +
    geom_line(data = dfData, aes(x=t, y=kalmanAngleMPU6050, colour = "Kalman MPU")) +
    ylab("Ángulo (rad)") + xlab("t (ms)") +
    theme_bw()
}

plotAnglesAGC_KmpuKcalc(theAxix="X")
plotAnglesAGC_KmpuKcalc(theAxix="Y")
plotAnglesAGC_KmpuKcalc(theAxix="Z")
```
```{r}
acc_compass <- angXY.df$rollAccX - angXY.df$rollXcompass
mean(acc_compass)*RAD_TO_DEG
#sd(acc_compass)*RAD_TO_DEG

acc_compass <- angXY.df$pitchAccY - angXY.df$pitchYcompass
mean(acc_compass)*RAD_TO_DEG
#sd(acc_compass)*RAD_TO_DEG

acc_compass <- angXY.df$yawAccZ - angXY.df$yawZcompass
mean(acc_compass)*RAD_TO_DEG
#sd(acc_compass)*RAD_TO_DEG

mean(angXY.df$rollXcompass)*RAD_TO_DEG
#sd(angXY.df$rollXcompass)*RAD_TO_DEG
mean(angXY.df$pitchYcompass)*RAD_TO_DEG
#sd(angXY.df$pitchYcompass)*RAD_TO_DEG
mean(angXY.df$yawZcompass)*RAD_TO_DEG
#sd(angXY.df$yawZcompass)*RAD_TO_DEG

```



Se muestra la salida del acelerómetro, giróscopo y brújula junto con su desviación standard:
```{r eval=FALSE}
# Plot values
plotAnglesAGC_sd <- function(theAxix="X"){
  if (theAxix == "X")
  {
    dfData <- data.frame(accAngle = angXY.df$rollAccX, 
                        csGyro=angXY.df$csGyroX,
                        rotationCompass=angXY.df$rollXcompass, 
                        accSD=angXY.df$rollAccX + sqrt(angXY.df$sd2AccX),
                        gyroSD=angXY.df$csGyroX + sqrt(angXY.df$sd2GyroX), 
                        compassSD=angXY.df$rollXcompass + sqrt(angXY.df$sd2CompassX),
                        t=angXY.df$micros/1000)
  }else if (theAxix == "Y")
  {
    dfData <- data.frame(accAngle = angXY.df$pitchAccY, 
                        csGyro=angXY.df$csGyroY,
                        rotationCompass=angXY.df$pitchYcompass, 
                        accSD=angXY.df$pitchAccY + sqrt(angXY.df$sd2AccY),
                        gyroSD=angXY.df$csGyroY + sqrt(angXY.df$sd2GyroY), 
                        compassSD=angXY.df$pitchYcompass + sqrt(angXY.df$sd2CompassY), 
                        t=angXY.df$micros/1000)
  }else if (theAxix == "Z")
  {
    dfData <- data.frame(accAngle = angXY.df$yawAccZ, 
                        csGyro=angXY.df$csGyroZ,
                        rotationCompass=angXY.df$yawZcompass, 
                        accSD=angXY.df$yawAccZ + sqrt(angXY.df$sd2AccZ),
                        gyroSD=angXY.df$csGyroZ + sqrt(angXY.df$sd2GyroZ), 
                        compassSD=angXY.df$yawZcompass + sqrt(angXY.df$sd2CompassZ), 
                        t=angXY.df$micros/1000)
  }
  
  mainAnglesGG <- ggplot(data=dfData, 
         aes(x=t, y=accAngle, colour="Acelerómetro")) +
    geom_line() +
    scale_colour_manual("", 
                      breaks = c("Acelerómetro", "Giróscopo", "Brújula", "acc SD", "gyro SD", "compass SD"),
                      values = c("Acelerómetro"="blue", 
                                 "Giróscopo"="black", 
                                 "Brújula"="red",
                                 "acc SD" = "cyan",
                                 "gyro SD"="gray",
                                 "compass SD"="darkorange"))
    
    
  mainAnglesGG +
    geom_line(data = dfData, aes(x=t, y=csGyro, colour = "Giróscopo")) +
    geom_line(data = dfData, aes(x=t, y=rotationCompass, colour = "Brújula")) +
    geom_line(data = dfData, aes(x=t, y=accSD, colour = "acc SD")) +
    geom_line(data = dfData, aes(x=t, y=gyroSD, colour = "gyro SD")) +
    geom_line(data = dfData, aes(x=t, y=compassSD, colour = "compass SD")) +
    ylab("Ángulo (rad)") + xlab("t (ms)") +
    theme_bw()
}

plotAnglesAGC_sd(theAxix="X")
plotAnglesAGC_sd(theAxix="Y")
plotAnglesAGC_sd(theAxix="Z")

```



Se testea la salida del magnetometro.
```{r}
dfData <- data.frame(yawZcompass = angXY.df$yawZcompass, 
                    horizontalHeadingAngle=angXY.df$horizontalHeadingAngle, 
                      t=angXY.df$micros/1000)
headingAnglesGG <- ggplot(data=dfData, 
       aes(x=t, y=yawZcompass, colour="Ang yawZcompass")) +
  geom_line() +
  scale_colour_manual("", 
                    breaks = c("Ang yawZcompass", "Ang horiz."),
                    values = c("Ang yawZcompass"="darkorange", 
                               "Ang horiz."="red"))
  ## ggtitle("Angulo eje X")
  
headingAnglesGG +
  geom_line(data = dfData, aes(x=t, y=horizontalHeadingAngle, colour = "Ang horiz.")) +
  ylab("Ángulo (rad)") + xlab("t (ms)") +
  theme_bw()
```


`heading` = yawZ

`horizontalHeadingAngle` se usan los ángulos de Euler.



```{r}
library(ggplot2)
dfData <- data.frame(yawZcompass = angXY.df$heading, 
                    horizontalHeadingAngle=angXY.df$horizontalHeadingAngle, 
                    kalAngleZ=angXY.df$kalAngleZ, 
                    t=seq(1:nrow(angXY.df)))
headingAnglesGG <- ggplot(data=dfData, 
       aes(x=t, y=yawZcompass, colour="heading.yawZ")) +
  geom_line() +
  scale_colour_manual("", 
                    breaks = c("heading.yawZ", "horizontalHeading", "kalAngleZ"),
                    values = c("heading.yawZ"="darkorange", 
                               "horizontalHeading"="tomato4", 
                               "kalAngleZ"="cyan"))
  ## ggtitle("Angulo eje X")
  
headingAnglesGG +
  geom_line(data = dfData, aes(x=t, y=horizontalHeadingAngle, colour = "horizontalHeading")) +
  geom_line(data = dfData, aes(x=t, y=kalAngleZ, colour = "kalAngleZ")) +
  ylab("Ángulo (rad)") + xlab("t (ms)") +
  theme_bw()
```

Diferencias entre `yawZcompass` y `horizontalHeadingAngle`:
```{r}
aux <- (dfData$yawZcompass - dfData$horizontalHeadingAngle)*RAD_TO_DEG
boxplot(aux, horizontal = TRUE)
sd(aux)
range(aux)
```


`kalAngleX` y `kalAngleY` entre [-$\pi$,$\pi$]:

```{r}
library(ggplot2)
dfData <- data.frame(kalAngleX = anglesInPI(angXY.df$kalAngleX), 
                    kalAngleY=anglesInPI(angXY.df$kalAngleY), 
                    kalAngleZ=angXY.df$kalAngleZ, 
                    t=seq(1:nrow(angXY.df)))
headingAnglesGG <- ggplot(data=dfData, 
       aes(x=t, y=kalAngleX, colour="Kalman AngleX")) +
  geom_line() +
  scale_colour_manual("", 
                    breaks = c("Kalman AngleX", "Kalman AngleY", "Kalman AngleZ"),
                    values = c("Kalman AngleX"="darkturquoise", 
                               "Kalman AngleY"="darkorange4", 
                               "Kalman AngleZ"="darkviolet"))


#"kalAngleX"="darkturquoise",
#"kalAngleY"="darkorange4",
#"kalAngleZ"="darkviolet"
  ## ggtitle("Angulo eje X")
  
headingAnglesGG +
  geom_line(data = dfData, aes(x=t, y=kalAngleX, colour = "Kalman AngleX")) +
  geom_line(data = dfData, aes(x=t, y=kalAngleY, colour = "Kalman AngleY")) +
  geom_line(data = dfData, aes(x=t, y=kalAngleZ, colour = "Kalman AngleZ")) +
  ylab("Ángulo (rad)") + xlab("t (ms)") +
  theme_bw()
```



Media:
```{r}
sapply(angXY.df[15:23], mean, na.rm = TRUE)
```

Desviación estándar:
```{r}
sapply(angXY.df[15:23], sd, na.rm = TRUE)
```



Media:
```{r}
sapply(angXY.df[3:5], mean, na.rm = TRUE)
```

Desviación estándar:
```{r}
sapply(angXY.df[3:5], sd, na.rm = TRUE)
```
```{r}
par(mfrow=c(3,1))

RAD_TO_DEG <- 180/pi

dfAux <- data.frame(rollAccX = anglesInPI(angXY.df$rollAccX), 
                    pitchAccY = anglesInPI(angXY.df$pitchAccY), 
                    yawAccZ = angXY.df$yawAccZ)


boxplot(dfAux$rollAccX * RAD_TO_DEG, horizontal=TRUE, 
        main="Roll acelerómetro. Eje X",  
        cex.main=0.8, xlab="grados")
boxplot(dfAux$pitchAccY * RAD_TO_DEG, horizontal=TRUE, 
        main="Pitch acelerómetro. Eje Y",  
        cex.main=0.8, xlab="grados")
boxplot(dfAux$yawAccZ * RAD_TO_DEG, horizontal=TRUE, 
        main="Yaw acelerómetro. Eje Z",  
        cex.main=0.8, xlab="grados")
```



Media (grados):
```{r}
sapply(dfAux*RAD_TO_DEG, mean, na.rm = TRUE)
```

Desviación estándar (grados):
```{r}
sapply(dfAux*RAD_TO_DEG, sd, na.rm = TRUE)
```
