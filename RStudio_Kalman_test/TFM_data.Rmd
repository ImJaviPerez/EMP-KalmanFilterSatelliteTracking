---
# Este documento tiene encoding: UTF-8
title: "TFM. Máster de Modelización Matemática Estadística y Computación"
subtitle: "Localización de satélites"
author: "F. Javier Pérez Ramírez. UPV-EHU"
date: "27 de enero de 2020"
output:
  pdf_document:
    keep_tex: yes
    number_sections: yes
    toc: yes
    toc_depth: 3
    fig_caption: yes
    fig_height: 4
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
    number_sections: yes
header-includes:
- \usepackage{float}          # To insert figures caption
- \floatplacement{figure}{H}  # To insert figures caption
- \usepackage{xcolor}
- \usepackage{framed}
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhead[LE,RO]{TFM}
- \fancyfoot{}
- \fancyfoot[LO,RE]{FJP. 2020}
- \fancyfoot[LE,RO]{\thepage}
bibliography: ./biblioTFM.bib
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message = FALSE, cache=TRUE)
#    include = FALSE prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.
#    echo = FALSE prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.
#    message = FALSE prevents messages that are generated by code from appearing in the finished file.
#    warning = FALSE prevents warnings that are generated by code from appearing in the finished.
#    fig.cap = "..." adds a caption to graphical results.
#    results='asis' = output as-is, i.e., write raw results from R into the output document
```

```{r echo=FALSE}
#
# Error in tools::file_path_as_absolute(output_file)
#
# It seems the bug is related with 1.9 version of rmarkdown, so the solution is to return to 1.8 version
#
# install.packages("devtools")
# library(devtools)
# install_version("rmarkdown",version=1.8)
#
```

```{r echo=FALSE}
# Remove variables
### rm(list=ls())
```

# Tratamiento de datos{#sec:ttoDatos}

```{r}
# Load libraries
# zoo object creation
library(zoo)
library(dlm)
library(data.table)
```


```{r}
# Data frame with movement data
### angXY.df <- read.table(file="data/resultadosKalman.txt", header=TRUE, sep = "\t")
angXY.df <- read.delim(file="data/resultadosKalman_out.txt", row.names=NULL)

# Calculate delta t in milliseconds
require(data.table)
angXY.df$dt <- (angXY.df$micros - shift(angXY.df$micros))/1000
# angXY.df$dt[1] = NA, so Fisrt dt = second dt
angXY.df$dt[1] <- angXY.df$dt[2]
```

Para el problema que estamos tratando bastaría con la aproximación por rectángulos dado que la diferencia entre ambas es "pequeña": en ningún caso se superan los 6 º de diferencia (ver figura (\ref{fig:diffTrapezRect})).

```{r  fig.pos="H", fig.cap="\\label{fig:diffTrapezRect}Diferencias entre el ajuste trapezoidal y el ajuste con rectángulos."}
# We will need some more variables
# Gyroscope angles
# Rectangle "integration"
# Inicial angle + cumsum(...)
rectangle.X <- angXY.df$rollAccX[1] + cumsum(angXY.df$dt * angXY.df$gyroXrate)/1000
rectangle.Y <- angXY.df$pitchAccY[1] + cumsum(angXY.df$dt * angXY.df$gyroYrate)/1000

# Trapezoidal integration
# Let's  imagine two rectangles with height omega_k and omega_(k-1)
# and width angXY.df$dt/2
require(data.table)
# omega_k + omega_(k-1)
sum.shift.rect <- angXY.df$gyroXrate + shift(angXY.df$gyroXrate)
# sum.shift.rect[1] = NA, so Fisrt angle = second angle
sum.shift.rect[1] <- sum.shift.rect[2]
# Inicial angle + cumsum(...)
trapezium.X <-angXY.df$rollAccX[1] + cumsum(sum.shift.rect * angXY.df$dt / 2)/1000

# omega_k + omega_(k-1)
sum.shift.rect <- angXY.df$gyroYrate + shift(angXY.df$gyroYrate)
# sum.shift.rect[1] = NA, so Fisrt angle = second angle
sum.shift.rect[1] <- sum.shift.rect[2]
# Inicial angle + cumsum(...)
trapezium.Y <- angXY.df$pitchAccY[1] + cumsum(sum.shift.rect * angXY.df$dt / 2)/1000

par(mfrow=c(2,1))
boxplot(rectangle.X - trapezium.X, horizontal=TRUE, 
        main="Diferencias ajuste (rectagular-trapezoidal). Eje X",  
        cex.main=0.8, xlab="grados")
boxplot(rectangle.Y - trapezium.Y, horizontal=TRUE, 
        main="Diferencias ajuste (rectagular-trapezoidal). Eje Y",  
        cex.main=0.8, xlab="grados")
# Maximum difference between rectangle and trapezium adjustment
max(abs(rectangle.X - trapezium.X))
max(abs(rectangle.Y - trapezium.Y))
```


```{r}
require(ggplot2)

plotAnglesRectTrapez <- function(theTitle="Ajuste rectangular y por trapecios", dfRectTrapez=dfAux){
  #### ggplot(dfRectTrapez, aes(x=t)) +                    # basic graphical object
  ####   geom_line(aes(y=rectangle), colour="blue") +  # first layer
    #### geom_line(aes(y=trapezium), colour="darkorange")  # second layer
  ggplot(data=dfRectTrapez, 
         aes(x=t, y=rectangle, colour = "Rectangular")) +
    geom_line() + 
    geom_line(data = dfRectTrapez, aes(x=t, y=trapezium, colour = "Trapecios")) +
    scale_colour_manual("", 
                        breaks = c("Rectangular", "Trapecios"),
                        values = c("Rectangular"="blue", "Trapecios"="darkorange")) +
    ggtitle(theTitle) +
    ylab("Ángulo (º)") + xlab("t (ms)") +
    theme_bw()
}

dfAux <- data.frame(rectangle = rectangle.X, trapezium = trapezium.X, t =  angXY.df$micros/1000)
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje X", dfRectTrapez=dfAux)

dfAux2 <- subset(dfAux,(t>12000 & t<16000))
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje X. Detalle",dfRectTrapez=dfAux2)

dfAux <- data.frame(rectangle = rectangle.Y, trapezium = trapezium.Y, t =  angXY.df$micros/1000)
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje Y", dfRectTrapez=dfAux)

dfAux2 <- subset(dfAux,(t>12000 & t<16000))
plotAnglesRectTrapez(theTitle="Ajuste rectangular y por trapecios. Eje Y. Detalle",dfRectTrapez=dfAux2)


```

Una vez leídos los datos del problema se crean dos nuevas columnas con la suma acumulada de los ángulos proporcionados por los giróscopos tal y como se ha descrito anteriormente (suma acumulada de rectángulos).

```{r}
## # Trapezoidal integration
## angXY.df$csGyroX <- trapezium.X
## angXY.df$csGyroY <- trapezium.Y

# Rectangles integration
angXY.df$csGyroX <- rectangle.X
angXY.df$csGyroY <- rectangle.Y

angXY <- zoo(angXY.df[c("rollAccX","pitchAccY","yawAccZ","gyroXrate","gyroYrate","gyroZrate","rollXcompass","pitchYcompass","yawZcompass")], order.by=angXY.df$micros)
```

Una vez cargados los datos, se comprueban su estructura, sus dimensiones y que no contiene valores perdidos.

```{r}
# Return the First part of the Object
head(angXY)
# Object dimensions
cat("\nDimensiones del objeto:", dim(angXY), "\n")
# Number of NAs
cat("\nNúmero de valores perdidos =", length(which(is.na(angXY))))
```

La figura (\ref{fig:initialData}) muestra los datos de movimiento del artilugio: velocidades angulares (`gyroXangle`, `gyroYangle`) en (º $s^{-1}$),  ángulos del acelerómetro (`acelX`, `acelY`, `acelZ`) en grados sexagesimales (º) y ángulos del giróscopo (`csGyroX`, `csGyroY`, `csGyroZ`) en grados sexagesimales (º).

```{r fig.pos="H", fig.cap="\\label{fig:initialData}Datos de movimiento del artilugio. Angulos (`acelX`, `acelY``, `acelZ`), velocidades angulares (`gyroXrate`, `gyroYrate`, `gyroZrate`) y ángulos de los giróscopos (`csGyroX`, `csGyroY`, `csGyroZ`)."}
plot.zoo(angXY, 
         xlab = "Tiempo (ms)", main = "Ángulo X. Ángulo Y. Ángulo Z")
```


# Kalman{#sec:kalman}

Modelo físico:

$$\theta(t) \approx \theta(t-1) + \Delta t \cdot \omega(t-1)$$

**Elección del modelo**

\begin{equation}\label{eqn:modeloIniPetris}
  \begin{aligned}
    X_t &=& &G_t X_{t-1} + \eta_t,& &\eta_t \stackrel{i.i.d.}{\sim} (0,W_t)& &&\\
    Y_t &=& &F_t X + \epsilon_t,& &\epsilon_t \stackrel{i.i.d.}{\sim} (0,V_t)& &t = 1 \ldots n&
  \end{aligned}
\end{equation}

con $\theta_0 \sim (m_0, C_0)$

La primera de las ecuaciones de (\ref{eqn:modeloIniPetris}) es la ecuación de observación y la segunda es la de estado. En este caso la parte observada corresponderá a los ángulos proporcionados por acelerómetro en torno a los ejes $X$ e $Y$.

Por tanto, podríamos tomar como vector de estado los tres ángulos y las tres velocidades y escribir la ecuación de estado así:

\begin{equation}
\begin{pmatrix}
  \theta_E(t) \\ \theta_N(t) \\ \theta_Z(t) \\ \omega_E(t) \\ \omega_N(t) \\ \omega_Z(t)
\end{pmatrix}
=
\begin{pmatrix}
  1 & 0 & 0  & \Delta t & 0 & 0 \\
  0 & 1 & 0  & 0 & \Delta t & 0 \\
  0 & 0 & 1  & 0 & 0 & \Delta t \\
  0 & 0 & 0  & 1 & 0 & 0 \\
  0 & 0 & 0  & 0 & 1 & 0 \\
  0 & 0 & 0  & 0 & 0 & 1 \\
\end{pmatrix}
\begin{pmatrix}
  \theta_E(t-1) \\ \theta_N(t-1) \\ \theta_Z(t-1) \\ \omega_E(t-1) \\ \omega_N(t-1) \\ \omega_Z(t-1)
\end{pmatrix} +
\begin{pmatrix}
  \eta_{\theta_E}(t-1) \\ \eta_{\theta_N}(t-1) \\ \eta_{\theta_Z}(t-1) \\ \eta_{\omega_E}(t-1) \\ \eta_{\omega_N}(t-1) \\ \eta_{\omega_Z}(t-1)
\end{pmatrix} 
\end{equation}

Esto *se parece* mucho a un modelo con tendencia lineal local, pero la diferencia es que la "pendiente" ya no es un componente inobservable, sino que disponemos de medidas de ella en cada eje.

La ecuación de observación sería:

\begin{equation}
\begin{pmatrix}
  \mathcal{A}_E(t) \\ \mathcal{A}_N(t) \\ \mathcal{A}_Z(t) \\
  \mathcal{G}_E(t) \\ \mathcal{G}_N(t) \\ \mathcal{G}_Z(t) \\ 
  \mathcal{C}_E(t) \\ \mathcal{C}_N(t) \\ \mathcal{C}_Z(t)
\end{pmatrix}
=
\begin{pmatrix}
  1&0&0 & 0&0&0 \\
  0&1&0 & 0&0&0 \\
  0&0&1 & 0&0&0 \\
  0&0&0 & 1&0&0 \\
  0&0&0 & 0&1&0 \\
  0&0&0 & 0&0&1 \\
  1&0&0 & 0&0&0 \\
  0&1&0 & 0&0&0 \\
  0&0&1 & 0&0&0
\end{pmatrix}
\begin{pmatrix}
  \theta_E(t) \\ \theta_N(t) \\ \theta_Z(t) \\ \omega_E(t) \\ \omega_N(t) \\ \omega_Z(t)
\end{pmatrix} +
\begin{pmatrix}
  \epsilon_{\mathcal{A}_E}(t) \\ \epsilon_{\mathcal{A}_N}(t) \\ \epsilon_{\mathcal{A}_Z}(t) \\ 
  \epsilon_{\mathcal{G}_E}(t) \\ \epsilon_{\mathcal{G}_N}(t) \\ \epsilon_{\mathcal{G}_Z}(t) \\ 
  \epsilon_{\mathcal{C}_E}(t) \\ \epsilon_{\mathcal{C}_N}(t) \\ \epsilon_{\mathcal{C}_Z}(t) \\ 
\end{pmatrix} 
\end{equation}


Podemos especificar las matrices de sistema del modelo así.
Hay que cambiar la matriz `GG`, para ello se crea la matriz `JGG` [@petris2009dynamic][pág. 45] :
El convenio es el siguiente: si un elemento de `JGG[i,j] = 0` es cero, el correspondiente término de `GG` es invariante. Si por el contrario un elemento de `JGG[i,j] = k` (es un entero `k` entero positivo), el elemento correspondiente de `GG` en el momento `s` se toma de la fila `s` y columna `k` de `X` = `X[s,k]`.

```{r}
# Se transforma Delta_t de millisegundos a segundos
Delta_t <- angXY.df$dt/1000

# Notacion Durbin
pDim <- 9
mDim <- 6

# m0 # dimension [m, 1]
a1 <- rep(0,mDim)
####a1 <- matrix(rep(0,mDim*pDim), nr=pDim)
# C0 # dimension [m,m]
P1 <- 10^7 * diag(mDim)

# Matrix by columns
# FF # dimension [p,m]
ZZ <- matrix(c(1,0,0, 0,0,0, 1,0,0, 
               0,1,0, 0,0,0, 0,1,0,
               0,0,1, 0,0,0, 0,0,1,
               0,0,0, 1,0,0, 0,0,0,
               0,0,0, 0,1,0, 0,0,0,
               0,0,0, 0,0,1, 0,0,0),nr=pDim)
# VV # dimension [p,p]
HH <- diag(1.3,pDim)
# GG # dimension [m,m]
TT <- diag(mDim)
# W # dimension [m,m]
QQ <-  diag(0.1,mDim)

# JGG # dimension [m,m]
JTT <- diag(0,mDim)
JTT[1,4] <- JTT[2,5] <- JTT[3,6] <- 1
# JTT[1,mDim-3] <- JTT[2,mDim-2] <- JTT[3,mDim-1] <- 1

modAGC <- dlm(m0 = a1, 
           C0 = P1, 
           FF = ZZ, 
           V = HH, 
           GG = TT, 
           W = QQ, 
           JGG = JTT, 
           X = Delta_t
           ) # matrix(Delta_t, nrow = length(Delta_t), ncol = 1)

modAGC$m0[1] = angXY.df$rollAccX[1]
modAGC$m0[2] = angXY.df$pitchAccY[1]
modAGC$m0[3] = angXY.df$yawZcompass[1]
modAGC$m0[4] = angXY.df$gyroXrate[1]
modAGC$m0[5] = angXY.df$gyroYrate[1]
modAGC$m0[6] = angXY.df$gyroZrate[1]

modAGC
```


Parece que tiene sentido imaginar que las varianzas correspondientes a diferentes ejes de un mismo sensor (acelerómetro o giróscopo) sean iguales (y en todo caso podríamos probar y contrastar). Lo mismo para las varianzas de observación. Por tanto, podemos especficar una matriz que reemplace parametros estimados en las matrices de ocvarianzas de nuestro modelo así:

```{r}
crearModAGC <- function(par) {
  modAGC$W[1,1] <- modAGC$W[2,2] <- modAGC$W[3,3] <- exp(par[1])
  modAGC$W[4,4] <- modAGC$W[5,5] <- modAGC$W[6,6] <- exp(par[2])
  
  modAGC$V[1,1] <- modAGC$V[2,2] <- modAGC$V[3,3] <- exp(par[3])
  modAGC$V[4,4] <- modAGC$V[5,5] <- modAGC$V[6,6] <- exp(par[4])
  modAGC$V[7,7] <- modAGC$V[8,8] <- modAGC$V[9,9] <- exp(par[5])
  return(modAGC)
}
```


Podemos ahora hacer la estimación:

```{r calculate_dlmMLE}
resultACG <- dlmMLE(angXY, parm=rep(1,5), build=crearModAGC)
resultACG
```



Reemplazamos los valores de los parámetros en nuestro modelo,

```{r}
modAGC <- crearModAGC(resultACG$par)
modAGC
```

Y filtramos:

```{r}
# All but first row, columns 1 and 2
kalmanR <- dlmFilter(angXY, modAGC, simplify=TRUE)$m[-1,1:2]
colnames(kalmanR) <- c("X","Y")
kalmanR <- zoo(kalmanR, order.by=index(angXY))
```

Comparemos, por ejemplo, para el ángulo $X$ (`rollAccX`):



Se muestra el ángulo **roll** y **pitch** de los tres disposivos + kalman



Pruebo a hacer un filtro de Kalman a mano. Se utiliza como base el que nos dio F.Tusell en las clases del máster. Pŕactica N4 del curso 2018-2019:


*innovations* Durbin,p.86:
$$v_t = y_t - E(y_t|Y_{t-1}) = y_t - Z_t a_t$$


```{r}
kalman3 <- function(y,x0,P0,Q,H) {
  # Los argumentos son una serie temporal
  # Q variaza del estado
  # H varianza de la obser
  
  # n Numero de muestras
  n <- nrow(y)
  
  # x es un vector de dimension [mDim,n]
  dims <- c(n,mDim)
  x <- array(rep(0,mDim), dims)
  
  # P Es una matriz de dimension [[mDim, mDim],n]
  dims <- c(mDim,mDim,n)
  P <- array(rep(0,mDim*mDim), dims)
  
  # Valores iniciales
  x[1,] <- x0
  P[,,1] <- P0
  
  # Se inicializa la verosimilitud [pDim, mDim]
  dims <- c(pDim,mDim)
  vero <- array(rep(0,pDim*mDim), dims)

  for (i in 1:(n-1)) {
    if (!anyNA(y[i])) {
      # Se calcula la innovacion. Ver Durbin p.86:
      # inno = y_t - E(y_t|Y_{t-1}) = y_t - Z_t a_t
      tmp <- fortify.zoo(y[i], name = "Date")
      inno <- array(tmp[2:(pDim+1)] - ZZ %*% x[i,])
  
      # Aqui Z_t tiene dimension [pDim,mDim]
      F <- ZZ %*% P[,,i] %*% t(ZZ) + H
      
      # La matriz de ganancia K_t = P_t/(P_t + H_t)
      # Durbin, p. 84: K_t = T_t P_t Z'_t / F_t
      # En este caso particular TT = matriz unidad
      K <- TT %*% P[,,i] %*% t(ZZ) %*% solve(F)
  
      vect_inno <- unlist(inno)
      x[i+1,] <- TT %*% x[i,] + K %*% vect_inno
  
      P[,,i+1] <- TT %*% P[,,i] %*% t(TT - K %*% ZZ) +  Q

      vero <- -0.5 * n * log(2*pi) - 0.5 * sum(det(F) + t(vect_inno) %*% solve(F) %*% vect_inno)
    } else {
      x[i+1,] <- x[i,]
      P[,,i+1] <- P[,,i] + Q
    }
  }
  
  vero <- -0.5*vero
  # Se retorna el estado y el valor de la verosimilitud

  return(list(x=x,P=P,vero=vero))
}
```

```{r}
# Initial Values
x0 <- rep(0,mDim)
# x0[1] = angXY.df$rollAccX[1]
# x0[2] = angXY.df$pitchAccY[1]
# x0[3] = angXY.df$yawZcompass[1]
# x0[4] = angXY.df$gyroXrate[1]
# x0[5] = angXY.df$gyroYrate[1]
# x0[6] = angXY.df$gyroZrate[1]

# We put same initial values used with Kalman Filter before to test that we obtain same results
x0 <- modAGC$m0
P0 <- P1 # diag(10^7,mDim)
result   <- kalman3(y=angXY, x0=x0, P0=P1, Q=modAGC$W, H=modAGC$V)
# result$x
# result$vero
```


Se plotea el resultado
```{r}
# Save values in data frame
angXY.df$calcKalmanX <- result$x[,1]
angXY.df$calcKalmanY <- result$x[,2]
angXY.df$calcKalmanZ <- result$x[,3]

# Plot values
plotAnglesAGC_KmpuKcalc <- function(theAxix="X"){
  if (theAxix == "X")
  {
    dfData <- data.frame(accAngleX = angXY.df$rollAccX, 
                        csGyro=angXY.df$csGyroX,
                        rollXcompass=angXY.df$rollXcompass, 
                        kalmanAngleMPU6050=angXY.df$kalAngleX,
                        kalmanR=kalmanR$X, 
                        kalmanRCalc=angXY.df$calcKalmanX,
                        t=angXY.df$micros/1000)
    mainAnglesGG <- ggplot(data=dfData, 
           aes(x=t, y=accAngleX, colour="Acelerómetro X")) +
      geom_line() +
      scale_colour_manual("", 
                        breaks = c("Acelerómetro X", "Giróscopo", "Brújula", "Kalman MPU", "kalman R", "Kalman R calc"),
                        values = c("Acelerómetro X"="blue", 
                                   "Giróscopo"="darkorange", 
                                   "Brújula"="red",
                                   "Kalman MPU" = "black",
                                   "kalman R"="green",
                                   "Kalman R calc"="darkorchid"))
      ## ggtitle("Angulo eje X")
      
    mainAnglesGG +
      geom_line(data = dfData, aes(x=t, y=csGyro, colour = "Giróscopo")) +
      geom_line(data = dfData, aes(x=t, y=rollXcompass, colour = "Brújula")) +
      geom_line(data = dfData, aes(x=t, y=kalmanAngleMPU6050, colour = "Kalman MPU")) +
      geom_line(data = dfData, aes(x=t, y=kalmanR, colour = "kalman R")) +
      geom_line(data = dfData, aes(x=t, y=kalmanRCalc, colour = "Kalman R calc")) +
      ylab("Ángulo (º)") + xlab("t (ms)") +
      theme_bw()
  }
  else
  {
    dfData <- data.frame(accAngleY = angXY.df$pitchAccY, 
                        csGyro=angXY.df$csGyroY,
                        pitchYcompass=angXY.df$pitchYcompass, 
                        kalmanAngleMPU6050=angXY.df$kalAngleY,
                        kalmanR=kalmanR$Y, 
                        kalmanRCalc=angXY.df$calcKalmanY, 
                        t=angXY.df$micros/1000)
    mainAnglesGG <- ggplot(data=dfData, 
           aes(x=t, y=accAngleY, colour="Acelerómetro Y")) +
      geom_line() +
      scale_colour_manual("", 
                        breaks = c("Acelerómetro Y", "Giróscopo", "Brújula", "Kalman MPU", "kalman R", "Kalman R calc"),
                        values = c("Acelerómetro Y"="blue",  
                                   "Giróscopo"="darkorange",
                                   "Brújula"="red",
                                   "Kalman MPU" = "black",
                                   "kalman R"="green",
                                   "Kalman R calc"="darkorchid"))
      ## ggtitle("Angulo eje Y")
      
    mainAnglesGG +
      geom_line(data = dfData, aes(x=t, y=csGyro, colour = "Giróscopo")) +
      geom_line(data = dfData, aes(x=t, y=pitchYcompass, colour = "Brújula")) +
      geom_line(data = dfData, aes(x=t, y=kalmanAngleMPU6050, colour = "Kalman MPU")) +
      geom_line(data = dfData, aes(x=t, y=kalmanR, colour = "kalman R")) +
      geom_line(data = dfData, aes(x=t, y=kalmanRCalc, colour = "Kalman R calc")) +
      ylab("Ángulo (º)") + xlab("t (ms)") +
      theme_bw()
  }
}

plotAnglesAGC_KmpuKcalc(theAxix="X")
plotAnglesAGC_KmpuKcalc(theAxix="Y")
```


```{r}
### cbind(kalmanR$X, angXY.df$calcKalmanX, kalmanR$X-angXY.df$calcKalmanX)
### mean(kalmanR$X-angXY.df$calcKalmanX)
```





Se testea la salida del magnetometro.
```{r}
dfData <- data.frame(yawZcompass = angXY.df$yawZcompass, 
                    horizontalHeadingAngle=angXY.df$horizontalHeadingAngle, 
                    horizontalHeadingAngle=angXY.df$horizontalHeadingAngle2, 
                    horizontalHeadingAngle=angXY.df$horizontalHeadingAngle3, 
                      t=angXY.df$micros/1000)
headingAnglesGG <- ggplot(data=dfData, 
       aes(x=t, y=yawZcompass, colour="Ang yawZcompass")) +
  geom_line() +
  scale_colour_manual("", 
                    breaks = c("Ang yawZcompass", "Ang horiz.", "Ang horiz.2", "Ang horiz.3"),
                    values = c("Ang yawZcompass"="darkorange", 
                               "Ang horiz."="red", 
                               "Ang horiz.2"="blue", 
                               "Ang horiz.3"="green"))
  ## ggtitle("Angulo eje X")
  
headingAnglesGG +
  geom_line(data = dfData, aes(x=t, y=yawZcompass, colour = "Ang yawZcompass")) +
  geom_line(data = dfData, aes(x=t, y=horizontalHeadingAngle, colour = "Ang horiz.")) +
  geom_line(data = dfData, aes(x=t, y=horizontalHeadingAngle, colour = "Ang horiz.2")) +
  geom_line(data = dfData, aes(x=t, y=horizontalHeadingAngle, colour = "Ang horiz.3")) +
  ylab("Ángulo (º)") + xlab("t (ms)") +
  theme_bw()
```
